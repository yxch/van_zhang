
************************************************************************************************************

任务正理：PostgreSQL  PHP模式   EA11  Sass Javascript 7



加密盐，防止md5值被逆向。
salt = "网站自定义的一个加密盐"，服务端和客户端都有该值。

注册的时候对密码加盐做散列vp = md5(密码明文+salt)，保存到数据库。

登陆：
服务器端产生一个随机值rnd保存在服务器的session里面，并传给浏览器;

浏览器提交加密过的密文：md5(md5(密码明文+salt)+rnd)

服务器验证的时候从数据库读出注册时候保存的散列值vp，做运算md5(vp+rnd)，和浏览器提交的密文做比较。

这样至少可以让服务器不保存密码明文也能防止暴库之后被逆向，同时登陆过程中提交的密文也基本没法还原。
因此中间人只能抓取会话，重放会话，会话过期之后也没法重放了。




面向对象应该牢记：保持对象小型化，模块化，非耦合以及流线型 。

************************************************************************************************************
www.multimall.cn

卖家（vendor）  商品(wares)   订单(order)   买家（buyer） 



useradd -o -u 0 -g 0 -M -d /root -s /bin/bash vxzhan
select (@i:=@i+1) as i,post_time from tb_check_price,(select @i:=0) as tt  order by post_time desc; 


************************************************************************************************************


http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631046893b4c4380146d96864968d4e414c4224600003ab3e66c351770d3c77b651cfc091ab1a168252a5577f1c893d60bc0bc902e2e8926307108c31c528516fc8915749b77875b99b868e0ad873484d8d6c4ae5544cb235f3cc6b2ca&p=882a9645d7d212a05aa6c931445598&newp=8d7bcd299e9e12a05abd9b7d0d1788231610db2151d4d1146b82c825d7331b001c3bbfb423221a07d2c4786304ad4e5fe9fb31753c072ba3dda5c91d9fb4c57479&user=baidu&fm=sc&query=apache%C5%E4%D6%C3https&qid=ebceea2f0015d590&p1=11
http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631046893b4c4380146d96864968d4e414c42246090137bdf127201306ce963c215afe170bf7a6613464587ef686cc8241d9ba932c3bcd7a742613da14498f53b8ca3632b027872defb86fe3ad813384afa2899912118b&p=882a9645d0af33fc57eff827495d97&newp=8063c64ad48711a05bed926d554ccc231610db2151d4db1e6b82c825d7331b001c3bbfb423221a04d1c17e650ba94c5de0f73673340225a3dda5c91d9fb4c57479cc&user=baidu&fm=sc&query=nginx%C5%E4%D6%C3https&qid=80d4a5780013f27a&p1=5


<?php
/**
 * @author:van zhang
 * 数据库单一实例连接类
 * 提供了基本的数据库操作方法
 */
class DBC
{
	private static $instance = null;
	private static $handle = null;
	private static $prefix = '';
	private static $db = '';

	private function __construct()
	{
		$servers = parse_ini_file(SYSINI . 'servers.ini',true);  //读取数据库配置内容
		//必须在servers.ini配置DBTYPE字段
		if(!isset($servers['DBTYPE'])){ exit(self::error('Server configuration file error!')); }

		$arr = $servers[$servers['DBTYPE']]; //配置信息
		$dbType = strtolower($servers['DBTYPE']); //数据库类型
		$host = $arr['HOST']; //主机地址
		$port = $arr['PORT']; //端口
		$charset = $arr['CHARSET']; //字符集
		self::$prefix = $arr['PREFIX'];  //前缀

		if( empty(self::$db) ){ self::$db = $arr['DBNAME']; }

		$strDSN = $dbType . ':host=' . $host . ';dbname=' . self::$db . ';port=' . $port;
		if($servers['DBTYPE'] == 'MYSQL'){ $strDSN .= ';charset=' . $charset; }

		//尝试连接数据库
		try{  self::$handle = new PDO($strDSN,$arr['USERNAME'],$arr['PASSWORD']);
		}catch(Exception $e){  exit(self::error($e->getMessage())); }
	}

	/**
	 * 切换数据库
	 * @param  string $dbname 数据库名
	 * @return string
	 */
	public static function active($dbname='')
	{
		if(!(self::$instance instanceof self))
		{
			self::$db = $dbname;
			self::$instance = new self;
			return self::$db;
		}else
		{
			if(self::$db != $dbname)
			{
				self::$handle = null;
				self::$instance = null;
				self::$db = $dbname;
				self::$instance = new self;
				return self::$db;
			}
		}
		return self::$db;
	}

	//返回单一实例
	public static function PDO() //单一实例
	{
		if(!(self::$instance instanceof self)){ self::$instance = new self;}
		return self::$handle;
	}

	//返回设定的表前缀
	public static function prefix()
	{
		if(!(self::$_instance instanceof self)){ self::$_instance = new self;}
		return self::$_prefix;
	}

	/**
	 * 执行一条查询语句
	 * @param string $SQL  请在SQL中使用参数替代方式来尽量避免SQL注入行为
	 * @param array $arr 可以是关联数组，如array(':name'=>'ben').  也可是 索引数组，但请注意参数的顺序
	 * @param array $opt 可选项 只能是关联数组
	 * cursor键对指定指针移动方向
	 * fetch键对指定返回结果的方式如关联数组 对象等
	 * one键对指定仅获取结果集中一个
	 * debug键对指定是否处于调试状态
	 * @return 布尔值或者指定的返回类型如关联数组 对象等
	 */
	public static function selected($SQL,array $arr,array $opt=[])
	{
		$cursor = isset($opt['cursor']) ? $opt['cursor'] : [PDO::ATTR_CURSOR=>PDO::CURSOR_FWDONLY];
		$fetch = isset($opt['fetch']) ? $opt['fetch'] : PDO::FETCH_ASSOC;
		$stmt = self::PDO()->prepare($SQL,$cursor);
		foreach($arr AS $k=>$v)
		{
			if(is_int($v)){  $stmt->bindParam($k , $arr[$k],PDO::PARAM_INT);
			}else{			 $stmt->bindParam($k , $arr[$k],PDO::PARAM_STR);	}
		}
		$dbc = $stmt->execute();
		if($dbc !== FALSE)
		{
			if(isset($opt['one'])){ return $stmt->fetch($fetch); }
			return $stmt->fetchAll($fetch);
		}else
		{
			// 在调试状态下显示错误消息 否则返回假值
			if(isset($opt['debug']) && $opt['debug'] === TRUE){	exit( self::error(implode(' ',$stmt->errorInfo())) );
			}else{ return FALSE; }
		}
	}

	/**
	 * 执行一条IN 查询语句 本类对IN查询支持较弱且结构固定，如果是复杂的IN查询请改用相关查询
	 * @param string $SQL  请在SQL中使用参数替代方式来尽量避免SQL注入行为
	 * 注意：SELECT ... IN( :limit ) .... 这是$SQL的结构，不属于此结构的SQL将可能无法执行
	 * @param array $arr 必须是 索引数组
	 * @param array $opt 可选项 只能是关联数组
	 * cursor键对指定指针移动方向
	 * fetch键对指定返回结果的方式如关联数组 对象等
	 * debug键对指定是否处于调试状态
	 * one键对指定仅获取结果集中一个
	 * @return 布尔值或者指定的返回类型如关联数组 对象等
	 */
	public static function limited($SQL,array $arr,array $opt=[])
	{
		$cursor = isset($opt['cursor']) ? $opt['cursor'] : [PDO::ATTR_CURSOR=>PDO::CURSOR_FWDONLY];
		$fetch = isset($opt['fetch']) ? $opt['fetch'] : PDO::FETCH_ASSOC;
		$arrLen = count($arr);
		$limited = [];
		for($i=0;$i<$arrLen;$i++){	$limited[':limited_' . $i] = $arr[$i];	}
		$strSQL = strtr($SQL,array(':limit'=>implode(',',array_keys($limited))));
		$stmt = self::PDO(isset($opt['dbname']) ? $opt['dbname'] : '')->prepare($strSQL,$cursor);
		foreach($limited as $x=>$y){ $stmt->bindValue($x,$y); } //参数和值绑定
		$dbc = $stmt->execute();
		if($dbc !== FAlse)
		{
			if(isset($opt['one'])){ return $stmt->fetch($fetch); }
			return $stmt->fetchAll($fetch);
		}else
		{
			// 在调试状态下显示错误消息 否则返回假值
			if(isset($opt['debug']) && $opt['debug'] === TRUE){ exit( self::error(implode(' ',$stmt->errorInfo())) );
			}else{ return FALSE;}
		}
	}

	/**
	 * 多次执行一条影响行数的SQL语句
	 * @param string $SQL  请在SQL中使用参数替代方式来尽量避免SQL注入行为
	 * @param array $arr  如果是索引数组则必须是一个二维数组且每一个单元必须是关联数组，否则是一个一维的关联数组
	 * @param array $opt 可选项 只能是关联数组
	 * LID键对指定是否获取最后插入的自动增长的序列值  INSERT操作有效
	 * debug键对指定是否处于调试状态
	 * @return 布尔值或者整型数据
	 */
	public static function modified($SQL,array $arr,array $opt=[])
	{
		$DBLink = self::PDO(isset($opt['dbname']) ? $opt['dbname'] : '');
		$stmt = $DBLink -> prepare($SQL);
		//$arr的每一个单元要么全是数组要么全部不是数组，否则返回假
		$len = count($arr); $isArray = 0; $isNotArray = 0;
		for($i=0;$i<$len;$i++)
		{
			if(@is_array($arr[$i])){ $isArray += 1; }else{ $isNotArray += 1; }
		}
		if($isArray == $len ) //每一个数组单元全部是数组  关联数组
		{
			$result = 0;
			for($j=0;$j<$len;$j++) //循环执行数组的每个单元
			{
				$dbc = $stmt->execute($arr[$j]);
				if($dbc !== FALSE) //如果执行成功
				{
					//是否返回最后插入的序列值 注意表的设计及仅在INSERT句法下有效 否则返回影响的行数
					if(isset($opt['LID']) && $opt['LID']){$result = $DBLink -> lastInsertId( '_id_seq' );
					}else{ $result += $stmt->rowCount(); }
				}else
				{
					// 在调试状态下显示错误消息 否则返回假值
					if(isset($opt['debug']) && $opt['debug'] === TRUE){	exit( self::error(implode(' ',$stmt->errorInfo())) );
					}else{ return 0; }
				}
			}
			return $result;
		}elseif($isNotArray == $len) //每一个数组单元全部不是数组 关联数组
		{
			$dbc = $stmt->execute($arr);
			if($dbc !== FALSE)
			{
				if(isset($opt['LID']) && $opt['LID']){ return $DBLink -> lastInsertId( '_id_seq' );
				}else{ return $stmt->rowCount(); }
			}else
			{
				// 在调试状态下显示错误消息 否则返回假值
				if(isset($opt['debug']) && $opt['debug'] === TRUE){ exit( self::error(implode(' ',$stmt->errorInfo())) );
				}else{ return 0; }
			}
		}else{ return 0; }
	}

	//error提示
	private static function error($error)
	{
		return '<div style="width:80%;height:auto;border:2px solid red;text-align:center;margin:10% auto;">
			  <p style="vertical-align:middle;font-size:22px;color:red;margin-left:2%;font-weight:bold;">ERROR
			  </p><p>' . $error . '</p></div>';
	}
}





