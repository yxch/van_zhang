<!DOCTYPE html>
<html>
<head>
	<title>MongoDB NOTEBOOK</title>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="/cross/css/reset.css" />
	<link rel="stylesheet" href="/cross/css/samples.doc.css" />
	<script src="/cross/js/jquery-3.min.js"></script>
	<script src="/cross/js/samples.doc.js"></script>
</head>
<body>
	<h1>Mongodb 索引<a href="http://www.sample.cn/index.html">索引页</a></h1>

	<h2>Introduction</h2>
	<div>
		<h3>API参考文档</h3>
		<div>
			<p><a href="https://docs.mongodb.com/manual/" target="_blank">MongoDB API参考文档</a></p>
			<p><a href="http://docs.mongoing.com/manual-zh/" target="_blank">MongoDB API中文参考文档</a></p>
		</div>

		<h3>简介</h3>
		<div>
			<p>MongoDB 由databases组成，databases由collections组成，collections由documents（相当于行）组成，而documents有fields（相当于列)组成。</p>
			<p>MongoDB是异步写数据</p>
			<p>文档是MongoDB中数据的基本单元，非常类似于关系数据库管理系统中的行(但比行要复杂得多)</p>
			<p>类似地，集合可以被看做是没有模式的表</p>
			<p>MongoDB的单个实例可以容纳从外独立的数据库，每一个都有自己的集合和权限</p>
			<p>MongoDB自带简洁但功能 强大的JavaScript Shell,这个工具对于管理MongoDB实例和操作数据作用非常大。</p>
			<p>每一个文档都有一个特殊的键"_id"，它在文档所处的集合是唯一的。</p>
		</div>

		<h3>Document Structure　文档结构</h3>
		<div>
			<p>MongoDB documents are composed of field-and-value pairs .MongoDB的文档是由字段和值组成（键值对）</p>
			<p>The value of a field can be any of the BSON data types, including other documents, arrays, and arrays of documents. For example, the following document contains values of varying types: 键的值可以是BSON类型的数据，包括其它的文档，数组，数组文档。参看如下示例：</p>
			<textarea>
			var mydoc = {
				_id: ObjectId("5099803df3f4948bd2f98391"),   _id holds an ObjectId  文档对象id
				name: { first: "Alan", last: "Turing" },	name可以是嵌入式的文档
				birth: new Date('Jun 23, 1912'),	日期类型
				death: new Date('Jun 07, 1954'),	日期类型
				contribs: [ "Turing machine", "Turing test", "Turingery" ],	数组
				views : NumberLong(1250000)	长整型数据类型
			 }
			</textarea>
			<p>MongoDB uses the dot notation to access the elements of an array and to access the fields of an embedded document. MongoDB</p>
			<p>使用句点访问任何数组单元，也可以使用这种方法访问任何嵌入式文档,如:<em>array.index   embedded document.field</em></p>
			<p><strong>注意：</strong></p>
			<p>The maximum BSON document size is 16 megabytes.  BSON文档的最大尺寸是16M。</p>
			<p>The maximum document size helps ensure that a single document cannot use excessive amount of RAM or, during transmission, excessive amount of bandwidth. To store documents larger than the maximum size, MongoDB provides the GridFS API. See mongofiles and the documentation for your driver for more information about GridFS.</p>
			<p>The _id field is always the first field in the document. 字段 _id总是文档的第一个字段</p>
			<p>Updates taht include renaming of field names may result in the reordering of fields in the document.修改包括重命名字段可能导致文档重排序。</p>
			<p>在一个集合中必须包含一个唯一键作_id为主键.如果此键未指定，MongoDB使用对象ObjectIds产生唯一值作为默认值</p>
			<p>另外，如果进程mongod收到插入文档的指令但此文档并未包括_id键时，Monod将使用ObjectId产生值并插入_id。</p>
			<p>The _id field may contain values of any BSON data type, other than an array.</p>

			<p>文档的键是字符串。除了少数例外情况，键可以使用UTF-8字符</p>
			<p>键不能含有\0（空字符)，这个字符用来表示键的结尾</p>
			<p>.和$有特殊的意义，只有在特定环境下才能使用。通常来说是被保留了，使用不当的话，驱动程序会提示</p>
			<p>以下划线"_"开头的键是保留的，但这个不是严格要求的</p>
			<p>MongoDB不但区分类型，也区分大小写。MongoDB的文档不能有重复的键。</p>
		</div>

		<h3>Field Names　字段名</h3>
		<div>
			<p>Field names are strings.　字段名是字符串</p>
			<p>Documents have the following restrictions on field names:<i>文档对字段名有如下严格要求：</i></p>
			<p>The field name _id is reserved for use as a primary key; its value must be unique in the collection, is immutable, and may be of any type other than an array.　字段_id是作为主键使用的，它的值在整个集合中唯一并且不可枚举，可以是除数组外的任何类型</p>
			<p>The field names cannot start with the dollar sign ($) character.<i>字段名不能以$开始</i></p>
			<p>The field names cannot contain the dot (.) character.　字段名不能包含.</p>
			<p>The field names cannot contain the null character.　字段名不能包含null</p>
		</div>

		<h3>BSON Types　BSON类型简介</h3>
		<div>
			<p>BSON is a binary serialization format used to store documents and make remote procedure calls in MongoDB. The BSON specification is located at bsonspec.org.</p>
			<p>详细内容请参考：<a href="https://docs.mongodb.com/manual/reference/bson-types/" target="_blank">https://docs.mongodb.com/manual/reference/bson-types/</a></p>
			<p>JSON can only represent a subset of the types supported by BSON. To preserve type information, MongoDB adds the following extensions to the JSON format:</p>
			<p><strong>Strict mode:</strong> Strict mode representations of BSON types conform to the JSON RFC. Any JSON parser can parse these strict mode representations as key/value pairs; however, only the MongoDB internal JSON parser recognizes the type information conveyed by the format.</p>
			<p><strong>mongo Shell mode</strong>. The MongoDB internal JSON parser and the mongo shell can parse this mode.</p>
			<p>Parsers and Supported Format</p>
			<p><strong>Binary</strong><textarea readonly>{ "$binary": "<bindata>", "$type": "<t>" }　　BinData ( <t>, <bindata> )</textarea></p>
			<p><strong>Date</strong>　　 In Strict mode, date is an ISO-8601 date format with a mandatory time zone field following the template YYYY-MM-DDTHH:mm:ss.mmm<+/-Offset>.<textarea readonly>{ "$date": "<date>" }　　new Date ( <date> )</textarea></p>
			<p><strong>Timestamp</strong><textarea readonly>{ "$timestamp": { "t": <t>, "i": <i> } }　　	Timestamp( <t>, <i> )</textarea></p>
			<p><strong>Regular Expression</strong><textarea readonly>{ "$regex": "<sRegex>", "$options": "<sOptions>" }　　/<jRegex>/<jOptions></textarea></p>
			<p><strong>OID　id is a 24-character hexadecimal string.</strong><textarea readonly>{ "$oid": "<id>" }　　ObjectId( "<id>" )</textarea></p>
			<p><strong>DB Reference</strong><textarea readonly>{ "$ref": "<name>", "$id": "<id>" }　　DBRef("<name>", "<id>")</textarea></p>
			<p><strong>Undefined Type</strong><textarea readonly>{ "$undefined": true }　　undefined</textarea></p>
			<p><strong>MinKey</strong><textarea readonly>{ "$minKey": 1 }　　MinKey</textarea></p>
			<p><strong>MaxKey</strong><textarea readonly>{ "$maxKey": 1 }　 MaxKey</textarea></p>
			<p><strong>NumberLong　　	New in version 2.6.</strong><textarea readonly>{ "$numberLong": "<number>" }　　NumberLong( "<number>" )</textarea></p>
		</div>
	</div>

	<h2>数据库和集合</h2>
	<div>
		<h3>创建数据库和集合</h3>
		<div>
			<p>MongoDB并不需要显式地创建数据。MongoDB在保存数据的时自动创建数据库。</p>
			<p>可以使用use database来切换数据.通过这种方式将全局变量db设置为你的数据库名.这意味着接下来所有输入到shell中的命令都将在你的数据库名中执行，除非将该变量重置为另一个数据库。</p>
			<p>为确保目前使用正确的数据库，在切换到某个数据库之前，最好先查看是否存在数据库。<strong>show dbs</strong></p>
			<p>查看数据库中的所有集合：<strong>show collections</strong></p>
			<p>在shell 中直接输入db,可以查看当前正在使用的数据库.</p>
			<p>创建固定集合</p>
			<p>与标准集合不同，固定集合必须使用createCollection函数以显式的方式创建。必须使用参数指定集合的大小。例如：</p>
			<p> db.createCollection("audit",{capped:true,size:20480});</p>
			<p>固定集合插入顺序一致，查询时不需要使用任何特殊的参数，任何其他特殊的命令或函数，除非希望逆转默认结果的顺序。这时将会用到$natural参数。</p>
			<p>例如查询固定集合中最近的10记录。db.audit.find().sort({$natural:-1}).limit(10);</p>
			<p>注意：已经添加到固定集合中的文档可以被更新，但文档大小不能改变。如果出现这种情况，更新将会失败。也不可以从固定集合中删除文档。相反，如果希望删除文档，就必须删除整个集合并重建。</p>
			<p>可以通过max参数限制添加到固定集合中的文档数量。例如：</p>
			<p>db.createCollection("audit100",{capped:true,size:20480,max:100});</p>
			<p>validate()函数调用可以评估一个集合可能会变得多大，检查现有集合已经使用的空间大小。db.audit100.validate();</p>

		</div>
		<h3>Command Helpers</h3>
		<div>
			<table>
				<tbody>
					<tr><th>命令</th><th>功能</th></tr>
					<tr><td>db.<collection>.help()</td><td>Show help on collection methods. The <collection> can be the name of an existing collection or a non-existing collection.</td></tr>
					<tr><td>show dbs</td><td>Print a list of all databases on the server.</td></tr>
					<tr><td>use &lt;db &gt;</td><td>Switch current database to <db>. The mongo shell variable db is set to the current database.</td></tr>
					<tr><td>show collections</td><td>Print a list of all collections for current database</td></tr>
					<tr><td>show users</td><td>Print a list of users for current database.</td></tr>
					<tr><td>show roles</td><td>Print a list of all roles, both user-defined and built-in, for the current database.</td></tr>
					<tr><td>show profile</td><td>Print the five most recent operations that took 1 millisecond or more.</td></tr>
					<tr><td>show databases</td><td>show databases</td></tr>
					<tr><td>db.version();</td><td>查看数据库版本</td></tr>
					<tr><td>db.serverStatus();</td><td>查看数据库状态</td></tr>
					<tr><td>关闭服务器</td><td>server mongod stop; db.shutdownServer();或者：killall -15 mongod</td></tr>
				</tbody>
			</table>
		</div>

		<h3>重命令集合</h3>
		<div>
			<p>db.media.renameCollection("newname");</p>
		</div>

		<h3>删除操作</h3>
		<div>
			<p>删除文档：db.newname.drop(); 删除全文档包括索引</p>
			<p>db.dropDatabase(); 删除数据库</p>
		</div>

	</div>

	<h2>The mongo Shell</h2>
	<div>
		<h3>mongo shell 简介</h3>
		<div>
			<p>mongo shell是mongoDB的一个交互界面,可以使用mongo shell查询和更新数据，执行管理员的操作。</p>
			<p>mongo shell 是mongodb发行版的一个组件。一旦你安装并启动了mongodb,就可以连接到mongodb shell运行mongodb实例。</p>
		</div>

		<h3>启动mongo shell</h3>
		<div>
			<p>At a prompt in a terminal window (or a command prompt for Windows), go to your <mongodb installation dir>: <strong>cd &lt mongodb installation dir &gt </strong></p>
			<p>Type ./bin/mongo to start mongo:  ./bin/mongo</p>
			<p>If you have added the <mongodb installation dir>/bin to the PATH environment variable, you can just type mongo instead of <strong>./bin/mongo</strong></p>
		</div>

		<h3>配置 mongo shell</h3>
		<div>
			<p><strong>自定义提示</strong>　在mongo shell中通过设置变量<i>prompt</i>来修改提示的内容。</p>
			<p>像javascirpt代码一样prompt变量是以字符串方式保存的。即使是函数也返回一些字符串.在每个提示中mongo可以动态显示信息。</p>
			<p>把要定义的逻辑代码写在.mongorc.js文件中，这样每次启动mongo shell 就会生效。(这个文件通常在用户主目录下  ls -a ~/.mongorc.js)</p>
			<p><strong>自定义提示显示操作数</strong></p>
			<p>如果要创建一个显示当前会话的操作数，可以像下面这样定义变量：</p>
			<textarea>
			cmdCount = 1;
			prompt = function() {   return (cmdCount++) + "> ";    }
			</textarea>
			<p>自定义显示数据库和主机名</p>
			<textarea>
			host = db.serverStatus().host;
			prompt = function() {    return db+"@"+host+"$ ";   }
			</textarea>
			<p>自定义显示系统启动时间(system up time and number of documents in the current database)和当前数据库的文档数目</p>
			<textarea>
			prompt = function() {  return "Uptime:"+db.serverStatus().uptime+" Documents:"+db.stats().objects+" > ";  }
			</textarea>
			<p>在mongo shell中使用自定义的编辑器</p>
			<textarea>
			export EDITOR=vim
			mongo
			</textarea>
			<p><strong>Change the mongo Shell Batch Size</strong></p>
			<p>db.collection.find()是从集合中检索数据的javascript方法。这个方法返回一个结果指针。但是在mongo shell中返回的指针并没有指向一个用var定义的关键字时，指针将迭代20次直到匹配到前20个文档。mongo shell也会提示 Type it to 再迭代20次。</p>
			<p>可以通过设置DBQuery.shellBatchSize属性值来改变这个值，比如把默认的20改到10。 DBQuery.shellBatchSize = 10;</p>
		</div>

		<h3>mongo shell 中使用帮助</h3>
		<div>
			<p><strong>Command Line Help 命令行帮助</strong></p>
			<p>To see the list of options and help for starting the mongo shell, use the --help option from the command line: <i>mongo --help</i></p>
			<p><strong>Shell help</strong> To see the list of help, in the mongo shell, type help: <i>help</i></p>
			<p><strong>Database Help</strong></p>
			<p>To see the list of databases on the server, use the show dbs command:  show dbs; <i>New in version 2.4: show databases is now an alias for show dbs</i></p>
			<p>To see the list of help for methods you can use on the db object, call the db.help() method: <i>db.help();</i> </p>
			<p>To see the implementation of a method in the shell, type the db.<method name> without the parenthesis (()), as in the following example which will return the implementation of the method db.updateUser():&nsbp;&nbsp; <i>db.updateUser</i></p>
			<p><strong>Collection Help</strong></p>
			<p>To see the list of collections in the current database, use the show collections command:  <i>show collections</i></p>
			<p>To see the help for methods available on the collection objects (e.g. db.<collection>), use the db.<collection>.help() method: <i>db.collection.help();</i></p>
			<p>&lt collection &gt can be the name of a collection that exists, although you may specify a collection that doesn’t exist.</p>
			<p>To see the collection method implementation, type the db.<collection>.<method> name without the parenthesis (()), as in the following example which will return the implementation of the save() method: <i>db.collection.save</i></p>
			<p><strong>Cursor Help</strong></p>
			<p>在mongo shell 中使用find()方法时，可能会使用变量去修改find()的行为和很多从find()方法返回指针执行的javascript方法。比如：</p>
			<p>To list the available modifier and cursor handling methods, use the db.collection.find().help() command: <i>db.collection.find().help()</i></p>
			<p>&lt collection &gt  can be the name of a collection that exists, although you may specify a collection that doesn’t exist.</p>
			<p>To see the implementation of the cursor method, type the db.<collection>.find().<method> name without the parenthesis (()), as in the following example which will return the implementation of the toArray() method: <i>db.collection.find().toArray</i></p>
			<p><strong>Some userful methods for handling cursors are:</strong></p>
			<p> <i>hasNext() </i> which checks whether the cursor has more documents to return.</p>
			<p> <i>next() </i> which returns the next document and advances the cursor position forward by one.</p>
			<p> <i> forEach(&lt function &gt) </i> which iterates the whole cursor and applies the <function> to each document returned by the cursor. The <function> expects a single argument which corresponds to the document from each iteration.</p>
			<p><strong>Wrapper Object Help</strong></p>
			<p>To get a list of the wrapper classes available in the mongo shell, such as BinData(), type help misc in the mongo shell: <i>help misc</i></p>
		</div>

	</div>

	<h2>Write Scripts for the mongo Shell</h2>
	<div>
		<h3>Opening New Connections</h3>
		<div>
		<p>从mongo shell或者javascript 文件,可以通过使用Mongo()构造函数来实例化数据库连接.</p>
		<textarea>
		new Mongo()
		new Mongo(<host>)
		new Mongo(<host:port>)
		var conn = new Mongo(); var db = conn.getDB("myDatabase");
		db = connect("localhost:27020/myDatabase");
		</textarea>
		</div>

		<h3>Differences Between Interactive and Scripted mongo</h3>
		<div>
			<p>You cannot use any shell helper (e.g. use <dbname>, show dbs, etc.) inside the JavaScript file because they are not valid JavaScript.你不能在javascript 文件内使用诸如这些帮助命令，因为它们不是有效的javascript.</p>
			<p>The following table maps the most common mongo shell helpers to their JavaScript equivalents.下面是shell命令到其等价的javascript映射表</p>
			<table>
			<tbody>
				<tr><th>Shell Helpers</th><th>Javascript equivalents</th></tr>
				<tr><td>show dbs, show databases</td><td>db.adminCommand('listDatabases')</td></tr>
				<tr><td>use &lt;db&gt;</td><td>db = db.getSiblingDB('<db>')</td></tr>
				<tr><td>show collections</td><td>db.getCollectionNames()</td></tr>
				<tr><td>show users</td><td>db.getUsers()</td></tr>
				<tr><td>show roles</td><td>db.getRoles({showBuiltinRoles: true})</td></tr>
				<tr><td>show log &lt;logname &gt;</td><td>db.adminCommand({ 'getLog' : '<logname>' })</td></tr>
				<tr><td>show logs</td><td>db.adminCommand({ 'getLog' : '*' })</td></tr>
				<tr><td>it</td><td>cursor = db.collection.find()if ( cursor.hasNext() ){   cursor.next();}</td></tr>
			</tbody>
			<p>To print all items in a result cursor in mongo shell scripts, use the following idiom:</p>
			<p>cursor = db.collection.find();</p>
			<p>while ( cursor.hasNext() ) { printjson( cursor.next() ); }</p>
			</table>
		</div>

		<h3>Data Type in the mongo Shell</h3>
		<div>
			<p><strong>Date</strong></p>
			<p>Date() method which returns the current date as string.</p>
			<p>new Date() constructor which returns a Date object using the ISODate() wrapper.</p>
			<p>ISODate() constructor which returns a Date object using the ISODate() wrapper.</p>
			<p>Internally, Date objects are stored as a 64 bit integer representing the number of milliseconds since the Unix epoch (Jan 1, 1970), which results in a representable date range of about 290 millions years into the past and future.</p>
			<p><strong>ObjectId</strong></p>
			<p>The mongo shell provides the ObjectId() wrapper class around the ObjectId data type. To generate a new ObjectId, use the following operation in the mongo shell: new ObjectId</p>
			<p><strong>NumberLong</strong></p>
			<p>By default, the mongo shell treats all numbers as floating-point values. The mongo shell provides the NumberLong() wrapper to handle 64-bit integers. NumberLong("2090845886852")</p>
			<p>db.collection.insert( { _id: 10, calc: NumberLong("2090845886852") } );</p>
			<p>db.collection.update( { _id: 10 },{ $set:  { calc: NumberLong("2555555000000") } } )</p>
			<p>db.collection.update( { _id: 10 },{ $inc: { calc: NumberLong(5) } } )</p>
			<p>db.collection.findOne( { _id: 10 } );结果：{ "_id" : 10, "calc" : NumberLong("2555555000005") }</p>
			<p><strong>NumberInt</strong></p>
			<p>By default, the mongo shell treats all numbers as floating-point values. The mongo shell provides the NumberInt() constructor to explicitly specify 32-bit integers.</p>


		</div>
	</div>

	<h2>MongoDB CREATE Operations</h2>
	<div>
		<h3>Create Operations</h3>
		<div>
			<p>Create or insert operations add new documents to a collection. If the collection does not currently exist, insert operations will create the collection.</p>
			<p><strong>db.collection.insert()</strong></p>
			<p><strong>db.collection.insertOne()</strong> New in version 3.2</p>
			<p><strong>db.collection.insertMany()</strong> New in version 3.2   inserts multiple documents into a collection. </p>
			<p>The method returns a document with the status of the operation. 操作结果：{ "acknowledged" : true, "insertedId" : ObjectId("5742045ecacf0ba0c3fa82b0")}</p>
			<p><strong>注意：</strong>In MongoDB, documents stored in a collection require a unique _id field that acts as a primary key. If the _id field is unspecified in the documents, MongoDB uses ObjectIds as the default value for the _id field; i.e. if a document does not contain a top-level _id field during an insert, the MongoDB driver adds the _id field that holds an ObjectId.</p>
			<p>The following methods can also add new documents to a collection：</p>
			<p><strong>db.collection.update()</strong> when used with the upsert: true option.</p>
			<p><strong>db.collection.updateOne()</strong> when used with the upsert: true option.</p>
			<p><strong>db.collection.updateMany() </strong>when used with the upsert: true option.</p>
			<p><strong>db.collection.findAndModify()</strong> when used with the upsert: true option.</p>
			<p><strong>db.collection.findOneAndUpdate()</strong> when used with the upsert: true option.</p>
			<p><strong>db.collection.findOneAndReplace()</strong> when used with the upsert: true option.</p>
			<p><strong>db.collection.save()</strong>.</p>
			<p><strong>db.collection.bulkWrite()</strong>.</p>
		</div>

		<h3>Query for Null or Missing Fields</h3>
		<div>
			<p>The { name : null } query matches documents that either contain the name field whose value is null or that do not contain the name field.</p>
			<p>If the query uses an index that is sparse, however, then the query will only match null values, not missing fields.</p>
			<p>The { name : { $type: 10 } } query matches documents that contains the name field whose value is null only; i.e. the value of the item field is of BSON Type Null</p>
			<p>The { name : { $exists: false } } query matches documents that do not contain the item field: db.users.find( { name : { $exists: false } } )</p>
		</div>

		<h3>Iterate a Cursor in the mongo Shell</h3>
		<div>
			<p>var myCursor = db.users.find( { type: 2 } );</p>
			<p>while (myCursor.hasNext()) {   print(tojson(myCursor.next()));	}</p>
			<p>Iterator Index</p>
			<p>var myCursor = db.inventory.find( { type: 2 } );</p>
			<p>var documentArray = myCursor.toArray();</p>
			<p>var myDocument = documentArray[3];  equivalent to myCursor.toArray() [1];</p>
		</div>


		<h3>Delete Operations</h3>
		<div>
			<p>Delete operations remove documents from a collection. MongoDB provides the following methods to delete documents of a collection:</p>
			<p><strong>db.collection.remove()</strong></p>
			<p><strong>db.collection.deleteOne()</strong> New in version 3.2</p>
			<p><strong>db.collection.deleteMany()</strong> New in version 3.2</p>
			<p>Delete operations do not drop indexes, even if deleting all documents from a collection.即使从集合中删除全部文档也不会删除索引</p>
			<p>To remove all documents from a collection, pass an empty filter document {} to either the db.collection.deleteMany() or the db.collection.remove() method.  db.users.deleteMany({});db.users.remove({});都可以删除全部文档</p>
			<p>To delete all documents from a collection, it may be more efficient to use the <strong>db.collection.drop()</strong> method to drop the entire collection, including the indexes, and then recreate the collection and rebuild the indexes.</p>
			<p>db.collection.deleteMany(); db.users.deleteMany({ status : "A" });删除所有status等于A的文档</p>
			<p>db.collection.deleteOne(); db.users.deleteOne( { status: "D" } ); 删除status等于A的一个文档.等同于db.users.remove( { status: "D" }, 1)</p>
			<p>db.collection.findOneAndDelete(). provides a sort option. The option allows for the deletion of the first document sorted by the specified order.</p>
			<p>db.collection.findOneAndModify(). db.collection.findOneAndModify() provides a sort option. The option allows for the deletion of the first document sorted by the specified order.</p>
			<p></p>
		</div>

		<h3>一次执行多个操作</h3>
		<div>
			<p>bulkWrite() Methods supports: insertOne updateOne updateMany replaceOne deleteOne deleteMany</p>
			<textarea>
			try {
			   db.characters.bulkWrite(
			    [
			         { insertOne :{"document" :{"_id" : 4, "char" : "Dithras", "class" : "barbarian", "lvl" : 4  } }
			         },
			         { insertOne :{"document" :{ "_id" : 5, "char" : "Taeln", "class" : "fighter", "lvl" : 3    }  }
			         },
			         {
			         	updateOne :{"filter" : { "char" : "Eldon" },"update" : { $set : { "status" : "Critical Injury" } }  }
			         },
			         {
			         	deleteOne : { "filter" : { "char" : "Brisbane"} }
			         },
			         { replaceOne : { "filter" : { "char" : "Meldane" },"replacement" : { "char" : "Tanys", "class" : "oracle", "lvl" : 4 }   }
			         }
			    ]
			   );
			}catch (e) {   print(e); }
			结果:
			{
			   "acknowledged" : true,
			   "deletedCount" : 1,
			   "insertedCount" : 2,
			   "matchedCount" : 2,
			   "upsertedCount" : 0,
			   "insertedIds" : {"0" : 4, "1" : 5 },
			   "upsertedIds" : {  }
			}
			</textarea>
		</div>
	</div>

	<h2>Read Operations</h2>
	<div>
		<h3>常规读操作</h3>
		<div>
			<p>Read operations retrieves documents from a collection; i.e. queries a collection for documents. MongoDB provides the following methods to read documents from a collection:</p>
			<p>IN查询：db.users.find( { status: { $in: [ "P", "D" ] } } );   查询status为P或者D的操作 相当于 SQL里的IN查询</p>
			<p>Although you can express this query using the $or operator, use the $in operator rather than the $or operator when performing equality checks on the same field.</p>

			<p>db.users.find({ $or: [ { status: "A" }, { age: { $lt: 30 } } ] });  OR操作</p>
			<p>db.users.find( { favorites: { artist: "Picasso", food: "pizza" } } ); 在字段内匹配操作</p>

			<p>排序升序：db.users.find( { status: "A" } ).sort( { user_id: 1 } ); SELECT * FROM users WHERE status = "A" ORDER BY user_id ASC</p>
			<p>排序倒序：db.users.find( { status: "A" } ).sort( { user_id: -1 } ); SELECT * FROM users WHERE status = "A" ORDER BY user_id DESC</p>
			<p>计算总数：db.users.count() or db.users.find().count(); SELECT COUNT(*) FROM users</p>
			<p>按条件计算总数：db.users.count( { user_id: { $exists: true } } ) or db.users.find( { user_id: { $exists: true } } ).count(); 相当于：SELECT COUNT(user_id) FROM users</p>
			<p>查询一条记录：db.users.findOne(); db.users.find().limit(1); SELECT * FROM users LIMIT 1;</p>
			<p>偏移：db.users.find().limit(5).skip(10); SELECT * FROM users LIMIT 1 SKIP 10;</p>
			<p>解释：db.users.find( { status: "A" } ).explain(); EXPLAIN SELECT * FROM users WHERE status = "A"</p>
			<p>去掉重复值：db.users.distinct( "status" ); 相当于:SELECT DISTINCT(status) FROM users</p>
			<p>distinct可以接受嵌套键：db.media.distinct("Tracklist.Title");</p>
			<p>db.users.find( { "favorites.artist": "Picasso" } ); 在字段内匹配操作 注意这里的引号包围了查询字段favorites.artist</p>
			<p>匹配数组：$in,$nin,$all 如：指定不在数组列表中　db.media.find({Released:{$in:[1999,2008,2009]},Type:"DVD"},{Cast:0});</p>
			<p>$slice操作返回部分：</p>
			<p>db.media.find({Title:"Matrix,The"},{Cast:{$slice:3}});返回前三项，返回后三项请用负。[2,3]从第二个开始返回三次，[-5,4]从倒数第5个开始返回4项</p>
			<p>db.users.find( { badges: [ "blue", "black" ] } ); Exact Match on an Array</p>
			<p>db.users.find( { badges: "black" } );  Match an Array Element</p>
			<p>db.users.find( { "badges.0": "black" } );  Match a Specific Element of an Array</p>
			<p>搜索奇数偶数项 $mod 该操作符把目标值除以2并检查运算余数是否为0.如：</p>
			<p>db.media.find({Released:{$mod:[2,0]}},{"cast":0});偶数项</p>
			<p>db.media.find({Released:{$mod:[2,1]}},{"cast":0});奇数项</p>
			<p>注意：$mod只能作用于整数，不能作用于包含了数值的字符串。</p>
			<p>$size过滤文档中数组大小符合条件的结果。比如搜索只含有两首歌的文档：db.media.find({Tracklist:{$size:2}});</p>
			<p>返回含有特定字段的对象：db.media.find({Author:{$exists:true}}); 注意 $exists不能使用索引;因此，使用$exists将会进行全表扫描。</p>

			<p>db.users.find( { 'points.0.points': { $lte: 55 } } );  字段points为数组的索引为0的键为points 小于或者等于55的文档</p>
			<p>The following methods can also read documents from a collection: db.collection.findOne() method is the db.collection.find() method with a limit of 1.</p>
			<p>db.users.find( { status: "A" }, { name: 1, status: 1 } ); 仅返回 name和status字段.</p>
			<p>db.users.find( { status: "A" }, { favorites: 0, points: 0 } ); 返回除了favorites和points之外的所有字段</p>
			<p>db.users.find( { status: "A" },{ name: 1, status: 1, "favorites.food": 1 }); 返回name status和字段favorites里的food</p>

		</div>

		<h3>比较查询</h3>
		<div>
			<p><strong>元操作符：</strong> $lt 小于　$lte 小于等于　$gt 大于 　$gte 大于等于　$ne 不等于</p>
			<p>db.users.find( { status: "A", age: { $lt: 30 } } ); 年龄小于30并且status为“A”的文档 </p>
			<p>db.users.find( { status: { $ne: "A" } }); 查找状态不等于A文档</p>
		</div>

		<h3>基于BSON类型匹配结果</h3>
		<div>
			<p>使用操作符$type可以基于数据的BSON类型匹配结果。比如：搜索所有含有曲目列表的文档，并且它们的曲目列表是嵌入对象类型. db.media.find({Tracklist:{$type:3}});</p>
			<p>参见BSON类型代码表。</p>
		</div>

		<h3>匹配完整的数组</h3>
		<div>
			<p>如果希望匹配文档中的完整数组，可以使用$elemMatch操作符。如果集合中有多个文档。其中一些文档含有一些相同的信息，那么此操作就非常有用了。默认的查询将无法 找到准确的文档，因为标准查询语法不匹配数组中的单个完整文档。</p>
			<p>db.users.find( { finished: { $elemMatch: { $gt: 15, $lt: 20 } } } );	</p>
			<p>比如搜索由Nirvana创作的含有歌曲"Smells Like Teen Spirit"的专辑，该歌曲应该是CD的第1首歌曲：db.media.find({Tracklist:{"$elemMatch":{Title:"Smells Like teen spirit",Track:"1"}}});</p>
			<p><strong>注意：</strong>$elemMatch, $slice, and $ are the only way to project specific elements to include in the returned array. For instance, you cannot project specific array elements using the array index; e.g. { "ratings.0": 1 } projection will not project the array with the first element.</p>
		</div>

		<h3>否定操作符</h3>
		<div>
			<p>可以使用$not元操作符否定任何标准操作符执行的检查。比如，返回所有的文档除由$elemMatch匹配的文档外：</p>
			<p>db.media.find({Tracklist:{$not:{"$elemMatch":{Title:"Smells Like teen spirit",Track:"1"}}});</p>
		</div>

		<h3>已知BSON类型代码</h3>
		<div>
			<table>
				<tbody>
					<tr><th style="width: 40%">代码</th><th style="width:60%;"></th></tr>
					<tr><td>-1</td><td>MiniKey</td></tr>
					<tr><td>1</td><td>Double</td></tr>
					<tr><td>2</td><td>Character字符串(UTF8)</td></tr>
					<tr><td>3</td><td>嵌入式对象</td></tr>
					<tr><td>4</td><td>嵌入式数组</td></tr>
					<tr><td>5</td><td>二进制数据</td></tr>
					<tr><td>7</td><td>对象ID</td></tr>
					<tr><td>8</td><td>Boolean型</td></tr>
					<tr><td>9</td><td>Date型</td></tr>
					<tr><td>10</td><td>Null</td></tr>
					<tr><td>11</td><td>正则表达式</td></tr>
					<tr><td>13</td><td>JavaScript代码</td></tr>
					<tr><td>14</td><td>Symbol</td></tr>
					<tr><td>15</td><td>带作用截至的JavaScript代码</td></tr>
					<tr><td>16</td><td>32位整型</td></tr>
					<tr><td>17</td><td>时间戳</td></tr>
					<tr><td>18</td><td>64位整数</td></tr>
					<tr><td>127</td><td>MaxKey</td></tr>
					<tr><td>255</td><td>MinKey</td></tr>
				</tbody>
			</table>
		</div>

		<h3>指定额外的查询表达式</h3>
		<div>
			<p>除了结构化查询语法外，还可以使用JavaScript指定额外的查询表达式。优点是非常灵活，并且允许执行大量的额外查询。缺点在于比原生操作符稍微慢一点。</p>
			<p>下面的所有代码都将返回 集合中发布年份早于1995年的DVD:</p>
			<p>db.media.find({Type:"DVD",Released:{$lt:1995}});</p>
			<p>db.media.find({Type:"DVD",$where:"this.Released < 1995"});</p>
			<p>db.media.find("this.Released < 1995");</p>
			<p>f = function(){ return this.Released < 1995;}; db.media.find(f);</p>
		</div>

		<h3>使用正则表达式</h3>
		<div>
			<p>MongoDB 允许在集合中搜索数据时使用正则表达式；不过，如果符合简单的前缀查询，那么它将尝试使用索引。</p>
			<p>比如：在media集合中搜索标题以"Matrix:"开头的所有文档：</p>
			<p>db.media.find({Title:/Matrix*/i});</p>
			<p>db.users.find( { user_id: /bc/ } ); 相当于 SELECT * FROM users WHERE user_id like "%bc%"</p>
			<p>db.users.find( { user_id: /^bc/ } ); 相当于 SELECT * FROM users WHERE user_id like "bc%"</p>
		</div>

		<h3>MongoDB的高级查询机制</h3>
		<div>
			<p>MongoDB提供了一些高级查询机制，用于解决处理大多数数据的问题。包括：全文搜索、聚集框架、MapReduce(映射和归约)</p>
			<p><strong>注意：</strong>如果误用这些高级特性，那么可能会在MongoDB节点中引发严重性能问题。</p>
			<p><strong>文本搜索</strong></p>
			<p>首先创建全文索引，然后指定希望索引的字段(用于执行全文搜索)。文本索引将遍历集合中的所有文档，并分析出每个文本字符串中的标记词干。这种标记和词干的过程将把文本分割成ynvk，在概念上它们接近于单词。接着MongoDB将取得互个记号的词干，然后找到该记号的根词汇。</p>
			<p>启用文本搜索的三种方式：</p>
			<p>1. --setParameter textSearchEnabled = true</p>
			<p>2. setParameter = textSearchEnabled = true</p>
			<p>3. db.adminCommand({setParameter:1,textSearchEnabled:true});</p>
			<p>使用文本索引</p>
			<p>创建文本索引的方式与创建其他索引的方式相同。例如，如果需要在博客集合的content元素上创建文本索引，那么可执行下面的命令：<strong>db.blog.ensureIndex({content:"text"});</strong>MongoDB会处理剩下的工作，并在数据库中插入文本索引。</p>
			<p>运行文本搜索命令：<strong>db.texttest.runCommand("text":{search:"fish"});</strong></p>
			<p>过滤文本搜索结果：db.texttest.runCommand("text",{search:'fish',filter:{about:"food"}});</p>
		</div>

	</div>

	<h2>Update Operations</h2>
	<div>
		<h3>常规更新操作</h3>
		<div>
			<p>Update operations modify existing documents in a collection. MongoDB provides the following methods to update documents of a collection:</p>
			<p><strong>db.collection.update()</strong> By default, the db.collection.update() method updates a single document. To update multiple documents, use the multi option.</p>
			<p><strong>db.collection.updateOne()</strong> New in version 3.2</p>
			<p><strong>db.collection.updateMany()</strong> New in version 3.2</p>
			<p><strong>db.collection.replaceOne()</strong> New in version 3.2 Replaces at most a single document that match a specified filter even though multiple documents may match the specified filter.</p>
			<p><strong>注意：</strong> Once set, you cannot update the value of the _id field nor can you replace an existing document with a replacement document that has a different _id field value.</p>
			<p>选项：upsert为真时，告诉MongoDB如果数据存在就更新，否则创建数据。multi为真时更新所有匹配的文档</p>
			<p>ome update operators, such as $set, will create the field if the field does not exist.</p>
			<p>However, at the document level, update() operations can add fields to existing documents using the $set operator.</p>
			<p>db.users.update( { }, { $set: { join_date: new Date() } }, { multi: true });</p>
			<p>However, at the document level, update() operations can remove fields from documents using the $unset operator.</p>
			<p>db.users.update( { },   { $unset: { join_date: "" } },{ multi: true });</p>
			<p>db.users.update(  { status: "A" } ,  { $inc: { age: 3 } },  { multi: true });UPDATE users SET age = age + 3 WHERE status = "A"</p>
			<p>示例：</p>
			<textarea>
			uses the $set operator to update the value of the favorites.food field to "pie" and the value of the type field to 3,
			uses the $currentDate operator to update the value of the lastModified field to the current date. If lastModified field does not exist, $currentDate will create the field. See $currentDate for details.
			db.users.updateOne(
			   { "favorites.artist": "Picasso" },
			   {
			     $set: { "favorites.food": "pie", type: 3 },
			     $currentDate: { lastModified: true }
			   }
			)
			To update multiple documents using the db.collection.update(), include the multi: true option:
			db.users.update(
			   { "favorites.artist": "Pisanello" },
			   {
			     $set: { "favorites.food": "pizza", type: 0,  },
			     $currentDate: { lastModified: true }
			   },
			   { multi: true }
			)
			</textarea>
			<p>To replace the entire content of a document except for the _id field, pass an entirely new document as the second argument to db.collection.replaceOne() or db.collection.update(). When replacing a document, the replacement document must consist of only &lt;field&gt; : &lt;value&gt;.</p>
			<p>The replacement document can have different fields from the original document. In the replacement document, you can omit the _id field since the _id field is immutable; however, if you do include the _id field, it must have the same value as the current value.</p>
			<p>The following methods can also update documents from a collection:</p>
			<p><strong>db.collection.findOneAndReplace().</strong></p>
			<p><strong>db.collection.findOneAndUpdate().</strong></p>
			<p><strong>db.collection.findAndModify().</strong></p>
			<p><strong>db.collection.save().</strong></p>
			<p><strong>db.collection.bulkWrite().</strong></p>
		</div>

		<h3>Save命令实现upsert</h3>
		<div>
			<p>可以使用save命令实现upsert。为了实现该操作，可以指定_id值；可以手动或自动添加该值 。如果不指_id值，save命令将认为它是一个插入操作，并将文档添加到集合中</p>
			<p>使用save的好处在于，不需要指定使用update()命令时所需要使用的upsert参数,也就是save提供了一种更快的方式来实现upsert数据操作。</p>
			<p>db.media.update({Title:"Matrix,The"},{Type:"DVD",Title:"Matrix,The",Released:"1999",Genre:"Action"},{upsert:true});</p>
			<p>db.media.save({Title:"Matrix,The"},{Type:"DVD",Title:"Matrix,The",Released:"1999",Genre:"Action"}); 此时Title值用作id字段</p>
		</div>

		<h3>设置信息</h3>
		<div>
			<p>$inc增加值：db.media.update({Title:"One Piece"},{$inc:{Read:4}}); 将read阅读量增加4</p>
			<p>设置字段值：db.media.update({Title:"Matrix,The"},{$set:{Genre:"Sci-Fi"}});</p>
			<p>删除指定字段：db.media.update({Title:"Matrix,The"},{$unset:{Genre:1}});</p>
		</div>

		<h3>操作数组</h3>
		<div>
			<p>在指定字段中添加某个值：db.media.update({"ISBN":"xxx-bbbb-aaaa"},{$push:{Author:Griffin,Stewie"}});</p>
			<p>$push操作符可以在指定字段中添加某个值。如果该字段是个数组，那么该值将被添加到数组中。如果该字段尚不存在，那么该字段的值将被设置为数组。如果该字段存在，但不是数组，那么将会抛出错误！</p>
			<p>指定多个值，如果希望在给定的数组中添加几个不同的值，可以使用可选的$each修改操作符：</p>
			<p>db.media.update({ISBN:"978-1-4302-582-6"},{$push:{Author:{$each:["Griffin,Peter","Griffin,Brian"]}}});</p>
			<p>使用$each时还可以使用$slice操作符，这样可以限制$push操作符中数组内元素的数量。$slice接受负数或0,使用负数时保证数组中的最后n个元素会被保留，而使用0则清空数组。</p>
			<p>$addToSet可以向数组中添加数据，如果数据在数组中存在是则不添加，它仅接受一个参数。但可以使用$each来绕开这个限制。</p>
			<p>db.media.update({ISBN:"978-1-4302-582-6"},{$addToSet:{Author:"Griffin,Brian"});该操作只能执行一次，第二次就不会向数组中添加了。</p>
			<p>从数组中删除最后一个或第一个元素：</p>
			<p>db.media.update({ISBN:"978-1-4302-582-6"},{$pop:{Author:1}}); 负数为删除最后的一个，正数为删除前面的一个。</p>
			<p>$pull从文档中删除所有的元素，db.media.update({ISBN:"978-1-4302-582-6"},{$pull:{Author:"Griffin,Stewie"}});</p>
			<p>$pullAll操作删除数组中多个不同的元素。db.media.update({ISBN:"978-1-4302-582-6"},{$pullAll:{Author:["Griffin,Louis","Griffin,Peter"]}});</p>
		</div>
	</div>

	<h2>原子操作</h2>
	<div>
		<h3>什么是原子操作</h3>
		<div>
			<p>MongoDB支持针对单个文档的原子操作。原子操作是一组可以结合在一起使用的操作。</p>
			<p>如果一组操作满足下面的条件，就可以称之为原子操作：</p>
			<p><i>1、</i>其它进程无法获得修改结果，除非整组操作都已经完成。</p>
			<p><i>2、</i>如果一个操作失败，整组操作都将失败，并全部回滚，数据将被恢复至运行原子操作之前的状态。</p>
		</div>
		<h3>以原子的方式修改和返回文档</h3>
		<div>
			<p>可以通过findAndModify命令实现对文档的原子操作。该命令将修改并返回文档。</p>
			<p>比如：找到了搜索的目标文档并在找到之后删除它：</p>
			<p>db.media.findAndModify({Title:"One Piece",sort:{Title:-1},remove:true});</p>
			<p>如下这个例子找到文档并更新它：</p>
			<p>db.media.findAndModify({query:{ISBN:"987-1-4302-3051-9"},sort:{Title:-1},update:{$set:{Title:" Different Title"}}});</p>
			<p>这些操作在完成之后都会返回旧文档,如果希望返回新文档，在后面加上new:true操作符。</p>
		</div>
	</div>

	<h2>创建索引</h2>
	<div>
		<h3>Mongo中创建索引</h3>
		<div>
			<p>一条经验法则是：对于需要在MySQL中创建索引的场合，在MongoDB中也应该创建索引.</p>
			<p>每个集合最多可以拥有40个索引。</p>
			<p>注意：添加索引将提高查询速度，但也会降低插入或删除的速度。最好在读操作多于写操作的集合中添加索引。但当写操作多于读操作时，索引甚至可能降低性能。</p>
			<p>db.users.createIndex( { user_id: 1 } );</p>
			<p>db.users.createIndex( { user_id: 1, age: -1 } );</p>
			<p>db.media.ensureIndex({Title:1}); 1表示升序，-1表示降序</p>
			<p>删除索引 db.media.dropIndex('Released_1'); 注意必须加上1或者-1</p>
		</div>

		<h3>与索引相关的函数</h3>
		<div>
			<p>强制使用某个索引查询数据,比如:</p>
			<p>db.media.find({ISBN:"978-1-4302-5821-6"}).hint({ISBN:-1}); 如果没有在该键上创建索引，结果将会是 error:{"$err","bad hint","code":10113},如果创建了索引，那么查询就会成功</p>
			<p>可以使用explain来确认是否使用指定的索引：db.media.find({ISBN:'987-1-4302-5821-6'}).hint({ISBN:1}).explain();</p>
			<p>函数min()和max()用来限制查询匹配，只有在指事实上的min和max键之间的索引键才会返回。</p>
			<p>min和max主要用于复合索引</p>
		</div>


	</div>

	<h2>引用数据库</h2>
	<div>
		<h3>手动引用数据库</h3>
		<div>
			<p>引用数据最简单和最直接方式就是手动完成。在手动引用数据时，可以将另一个文档中的_id存储在该文档中。</p>
			<p>示例</p>
			<textarea>
			db.publishers.insert({_id:"Apress",Type:"Technical Publisher",Category:["IT","Software","Programming"]});
			db.media.insert({Type:"Book",Title:"Definitive Guide to MongoDB 2nd ed., The",ISBN:"987-1-4302-5821-6",Publisher:"Apress",Author:["Hows,David","Plugge,Elelco","Membrey,Peter","Hawkins,Tim"]});
			book = db.media.findOne();  // 定义一个变量 把集合保存在变量中
			db.publishers.findOne({_id:book.Publisher});  // 使用变量
			</textarea>
		</div>
		<h3>使用DBRef引用数据</h3>
		<div>
			<p>DBRef标准提供了在文档之间引用数据的更正式规范。使用DBRef而不是手动引用的主要原因是，引用中文档所在的集合可能发生变化。所以，如果引用的一直都是相同的集合，那么手动引用数据也是可以。</p>
			<p>{$ref:&lt;collectionname&gt;,$id:$lt;id value &gt;[,$db:$lt;database name $gt;]}</p>
			<p>collectionname代表着被引用集合的名字,id value代表被引用对象的_id字段，通过使用可选的$db可以引用其它数据库中的文档。</p>
		</div>
	</div>

	<h2>GridFS</h2>
	<div>
		<h3>GridFS</h3>
		<div>
			<p>GridFS使用了两种集合Collection来存储数据</p>
			<p>show collections;</p>
			<p>fs.chunks</p>
			<p>fs.files</p>
			<p>system.indexes</p>
			<p>fs.files集合包含了文件的元数据，而fs.chunks集合则存储实际的以256KB尺寸进行分割的文件块。</p>
			<p>如果你有分片的集合，那么文件块会分布到多台服务器上，或许能获得比文件系统更好的性能。</p>
			<textarea>
				db.fs.files.findOne();
				{
				"_id" : ObjectId("530cf1bf96038f5cb6df5f39"),
				"filename" : "./conn.log",
				"chunkSize" : 262144,
				"uploadDate" : ISODate("2014-02-25T19:40:47.321Z"),
				"md5" : "6515e95f8bb161f6435b130a0e587ccd",
				"length" : 1644981
				}
			</textarea>
			<p>MongoDB还在files_id和文件块数中创建了复合索引，以帮助快速访问这些文件块 db.fs.chunks.getIndexes();</p>
			<p><strong>GridFS的模块</strong></p>
			<p>如果你想把存储在MongoDB的GridFS的文件直接服务于Web服务器或文件系统，那么你可以使用下面的GridFS插件：</p>
			<p>1）GridFS-Fuse：让GridFS的文件直接服务于文件系统</p>
			<p>2）GridFS-Nginx：让GridFS的文件直接服务于Nginx</p>
		</div>

		<h3>命令行方式mongofiles</h3>
		<div>
			<p>mongofiles命令行下向Mongodb数据库中插入文件数据。</p>
			<p><strong>mongofiles  -host 127.0.0.1:27017 -d  mydb  put  文件名</strong></p>
			<p>向数据库mydb中插入一个文件，其中put为命令，表示向Mongodb中上传文件，get、delete分别表示取得文件和删除文件。</p>
			<p>执行 db.fs.files.find()即可看到GridFS中的文件列表</p>.
			mongo自带有一个实现mongofliles，基本操作如下：
			<table>
				<tbody>
					<tr><th>命令或参数</th><th>解释说明</th></tr>
					<tr><td>–d </td><td>指定数据库 ，默认是fs，Mongofiles list –d testGridfs</td></tr>
					<tr><td>-u –p</td><td>指定用户名，密码</td></tr>
					<tr><td>-h</td><td>指定主机</td></tr>
					<tr><td>-port</td><td>指定主机端口</td></tr>
					<tr><td>-c</td><td>指定集合名，默认是fs</td></tr>
					<tr><td>-t </td><td>指定文件的MIME类型，默认会忽略</td></tr>
					<tr><td>mongofiles list</td><td>列出所有文件</td></tr>
					<tr><td>mongofiles put xxx.txt</td><td>上传一个文件</td></tr>
					<tr><td>mongofiles get xxx.txt</td><td>下载一个文件</td></tr>
					<tr><td>mongofiles search xxx </td><td>会查找所有文件名中包含“xxx”的文件</td></tr>
					<tr><td>mongofiles list xxx</td><td>查找所有文件名以“xxx”为前缀的文件</td></tr>
				</tbody>
			</table>
		</div>

		<h3>使用GridFS的理由</h3>
		<div>
			<p><strong>1）存储用户产生的文件内容</strong></p>
			<p>大多数Web应用都允许用户上传文件。当用户使用关系数据库时，这些用户产生的文件会存储在文件系统中，与数据库相隔离，而不是放在数据库内。这就带来了一些问题。如何将文件复制到所有需要文件的服务器上？当文件删除后，怎样删除所有的拷贝？怎样保障文件的安全以及做灾备呢？GridFS很好地解决了这些问题，你可以利用你的数据库备份来备份你的文件。而且由于MongoDB自身的复制技术，在MongoDB集群中的每一个副本处都有你的文件拷贝。删除文件跟删除数据库中的对象一样简单。</p>
			<p><strong>2）访问文件内容的分区</strong></p>
			<p>当把文件上传到GridFS后，文件会被分割成大小为256KB的块，并单独存放。因此当你需要读文件中的某个范围的字节时，只需把相应的文件块载入内存，而无需把整个文件加载到内存。这一点对于选择读或编辑尺寸很大的媒体内容文件时非常有用。</p>
			<p><strong>3）在MongoDB中存储16MB以上的文件</strong></p>
			<p>MongoDB默认的文件大小上限为16MB。所以，如果你的文件超过了16MB，那么你就应该使用GridFS。</p>
			<p><strong>4）克服文件系统的限制</strong></p>
			<p>如果你需要存储大量的文件，你就需要考虑文件系统自身的限制，因为文件系统对目录下的文件数量是有要求的。而使用GridFS后，你无需再担心这个问题。GridFS和MongoDB的分片使得你的文件可以分布到多个服务器上，而且没有增加操作的复杂性。</p>
		</div>
	</div>


	<h2>PHP 与 MongoDB</h2>
	<div>
		<h3>连接MongoDB</h3>
		<div>
			<p>连接到数据库： $c = new MongoClient(); </p>
			<p>选择数据库：$c->selectDB("contacts");</p>
			<p>选择希望连接的数据库，例如 contacts:  $c->contacts; </p>
			<p>选择连接的数据库和集合：$c->contacts->people;</p>
			<p>或者选择连接的数据库和集合：$c->selectDB("contacts")->selectCollection("people");</p>
			<p>Mongo类包含两个额外的命令：listDBs()和listCollections();</p>
			<p>print_r($c->listDBs());  print_r($c->listCollections());</p>
			<p>MongoClient类包含了close函数，用于断开与数据库服务器的PHP会话，事实上很少用到，因为驱动在Mongo对象超出有效范围时，自动关闭数据库连接。$c->close();</p>
		</div>

		<h3>插入数据</h3>
		<div>
			<p>$c = new MongoClient();  $collection = $c -> contacts -> people; $collection -> insert($data);</p>
			<p>insert()可以有5个选项：fsync、j、w、wtimeout、timeout</p>
			<p>fsync：boolean值，如果为真，MongoDB在确认数据插入在功之前，将会强制把数据写入硬盘。该选项将把选项w的任何设置覆写为0。</p>
			<p>j：boolean值,默认值假，真时MongoDB在确认插入数据之前，将强制把数据写入日志。</p>
			<p>w：可用于确认或不确认写操作(该选项也用于remove()和update()函数)。如果设置为0，写操作将不会得到确认；设置为1，写操作将会被 主服务器确认。使用复制集时，w可以被设置为n，用于确保主服务器在将数据修改成功地复制到n个节点后确认该写操作。还可以设置为majority即保留字符串用于保证复制集的大部分节点或特定标签中的节点都确认该 写操作。默认值为1。</p>
			<p>wtimeout：用于指定服务器等待接收确认的时间(以毫秒为单位)。默认值10000.</p>
			<p>timeout选项用于指定客户端需要等待服务器响应的超时时间(以毫秒为单位)</p>
			<p>示例：$options=['w'=>1,'wtimeout'=>5000]; $collection->insert($data,$options);</p>
		</div>

		<h3>查询数据</h3>
		<div>
			<p>$collection->findOne(); $collection->findOne(['Last Name'=>'Moran']);</p>
			<p>$collection = $c->contacts->people;  $cursor = $collection -> find();  while($document = $cursor->getNext()){ print_r($document); }</p>
			<p>其它的操作基本与shell操作相同，变成数组就可以了。</p>
			<p>PHP的Mongo驱动提供了自己的类:MongoRegex类，通过使用该类可以创建正则表达式。</p>
			<table>
				<tbody>
					<tr><th>标志</th><th>解释</th></tr>
					<tr><td>i</td><td>表示忽略大小写</td></tr>
					<tr><td>m</td><td>表示搜索将跨越多行(换行)内容</td></tr>
					<tr><td>x</td><td>允许搜索包含#注释的内容</td></tr>
					<tr><td>l</td><td>指定区域设置</td></tr>
					<tr><td>s</td><td>也称为dotall， “.”可用于匹配一切，包含换行。</td></tr>
					<tr><td>u</td><td>匹配Unicode字符.</td></tr>
				</tbody>
			</table>
			<p>正则使用示例：</p>
			<textarea>
				$c = new MongoClient();
				$collection = $c->contacts->people;
				$regex = new MongoRegex("/stradgynl/i");
				$cursor = $collection -> find(["Address.Place"=> $regex]);
				while($doc = $cursor -> getNext()){	 print_r($doc);	}
			</textarea>
		</div>

		<h3>更新数据</h3>
		<div>
			<p>PHP版本的update()函数最少接受两个参数：第一个参数用于指定更新的目标对象；第二个参数指定用于更新匹配记录的对象。</p>
			<p>upsert：如果此值为真，并且搜索条件未被匹配，那就创建一个新的文档。</p>
			<p>multiple：如果值为真，那么匹配该搜索条件的所有文档都将更新。</p>
			<p>fsync：如果值为真，那么数据将在更新结果返回前同步到磁盘。此时即使w已经设置了其他值 ，也会把选项w设置为0.</p>
			<p>w：如果设置为0,更新操作将不会得到确认。在使用复制集时，可以将它设置为n,保证主服务器在将侯复制到n个节点后才确认该更新操作。还可以设置为majority,一个保留字符串，用于保证大多数复制节点或特定标签中的节点都确认该更新操作。默认值为1,表示确认更新操作。</p>
			<p>j：如果值为真，那么数据将在更新结果返回之前写入到日志中。默认为假。</p>
			<p>wtimeout：指定服务器等待接收确认的超时时间。默认为10000毫秒。</p>
			<p>timeout：指定客户端需要等待数据库返回的时间。</p>
			<p>$inc增加特定键的值。搜索所有年龄小于40岁的人 $criteria = ['Age'=>['$lt'=>40]]; 使用$inc将他们的年龄增加3岁：$update = ['$inc'=>['Age'=>3]]; $opt = ['upsert'=>true];   执行：$collection->update($criteria,$update,$opt);</p>
			<p>$set 可以修改某个键的值而忽略其它任何字段，这样指定被修改的信息：$update = ['$set'=>['First Name'=>'Vicky']];</p>
			<p>$unset 用于从文档中删除指定的字段，工作方式与$set类似。</p>
			<p>$rename 重命名字段，该操作符将在每个文档及其数组和子文档中搜索指定的字段名。</p>
			<p>$push 如果指定的字段是一个数组，那么数据将被添加到其中，如果指定字段不存在，将创建该字段。如果存在指定字段但不是数组，将会抛出错误。</p>
			<p>$push和$each 可以向指定的字段中添加多个值。$update = ['$push'=>['E-Mail'=>['$each'=>['a','b']]]];</p>
			<p>$addToSet 类似于$push但如果目标数组不包含该数据时才将数据添加到数组中。接受一个数组作为参数。也可和$each结合使用。</p>
			<p>$pop 可以从数组中删除元素 -1删除第一个元素，1删除最后一个元素。</p>
			<p>$pull 删除所有指定值 </p>
			<p>$pullAll 删除多个元素 $update = ['$pullAll'=>['E-Mail'=>['vw@mongo.db','vw@office.com']]]</p>
			<p>save() 函数更新或插入数据,类似于update()函数，但save()可以更新已有的字段。与update具有同样的选项。</p>
			<p>findAndModify() 函数以原子方式更新文档。并且在更新成功之后返回结果，它将个文档，并且默认返回的修改之前的文档。只有在指定额外的参数new时，它才会返回修改后的就这样。</p>
			<p>remove() 函数用于删除文档，选项justOne如果设置为真，最多只有一个匹配条件的文档将被删除。其它fsync,j,w,wtimeout,timeut与update相同。</p>
			<p><strong>警告：</strong>在删除文档时，要记住文档的引用仍然会保留数据库中。确保手动删除或更新了这些被删除文档的引用；否则，这些引用在执行时将返回null。</p>
			<p>drop()用于删除整个集合，包含索引。</p>
		</div>

		<h3>DBRef</h3>
		<div>
			<p>与shell操作类似地有两种方式创建引用，手动方式和DBRef规范。</p>
			<p>手动引用示例：</p>
			<textarea>
				$c = new MongoClient();
				$db = $c ->contacts;   选择数据库
				$people = $db -> people; 选择集合people
				$addresses = $db -> addresses;  选择集合addresses

				$address = ['Street' => 'St. Anastraat 44','Place'=> 'Monster','Postal Code'=> '2681 SR','Country'=>'Netherlands'];
				$addresses -> insert($address); 保存地址

				$contact = ['First Name'=>'Melvyn','Last Name' => 'Babel','Age'=> 35,'Address'=>$address['_id']];
				$people -> insert($contact);
			</textarea>
			<p>使用DBRef实现引用，因为DBRef将使用一种通用格式，数据库和所有驱动都能识别。 </p>
			<textarea>
				$c = new MongoClient();
				$db = $c ->contacts;   选择数据库
				$people = $db -> people; 选择集合people
				$addresses = $db -> addresses;  选择集合addresses

				$address = ['Street' => 'WA Viser het hooftlaan 2621','Place'=> 'Driebergen','Postal Code'=> '3972 SR','Country'=>'Netherlands'];
				$addresses -> insert($address);

				$addressRef = MongoDBRef::create($addresses->getName(),$address['_id']);   getName()函数用于获取集合的名称
				$contact = ['First Name'=>'Ivo','Last Name' => 'Lauw','Age'=> 24,'Address'=>$addressRef;
				$people -> insert($contact);

				获取信息
				$people = $c -> contacts->people;
				$lastname = ['Last Name'=>'Lauw'];
				$person = $people -> findOne($lastname);
				$address = MongoDBRef::get($people -> db,$person['Address']);
				print_r($address);
			</textarea>
		</div>

		<h3>GridFS</h3>
		<div>
			<p>存储上传文件示例：</p>
			<textarea>
				$c = new MongoClient();
				$db = $c -> contacts;
				$gridFS = $db -> getGridFS();    定义GridFS类用于保证我们可以处理文件
				$file = 'fileField';  指定html字段的name特性
				$metadata = ['uploadDate'=>date()]; 元数据
				$id = $gridFS -> storeUpload($file,$metadata);  将文件上传至数据库

				在已存储的文件中添加元数据
				$metadata = ['$set'=>['Tag'=>'Avatar']];
				$criteria = ['_id' => $id];
				$db -> gridFS -> update($criteria,$metadata);

				获取已存储文件的名称
				$cursor = $gridFS -> find();
				foreach($cursor as $object){ echo "Filename:" . $object -> getFilename(); }

				$id = new MongoId('AAAAAAAAAAAA');
				$file = $gridFS -> findOne(['_id' => $id]);
				header('Content-Type:image/jpeg');
				echo $file -> getBytes(); exit;

				删除数据
				$id = new MongoId('AAAAAAAAAAAA');
				$file = $gridFS -> findOne(['_id' => $id ]);
				$gridFS -> delete($id);

			</textarea>
		</div>

		<h3>Map 和 Reduce</h3>
		<div>
			<p>在mongoDB的mapReduce实现中，它将对指定的集合执行一个专门的查询，所有匹配该查询的文档都将被输入到map函数中。map函数被设计用于生成键/值对。任何含有多个值的键都被输入到reduce函数中，reduce函数将返回输入数据的聚集结果。在此之后，还有一个可选的步骤，通过finalize的函数对数据的显示进行完善。</p>
		</div>

	</div>

	<h2>管理MongoDB</h2>
	<div>

		<h3>备份数据</h3>
		<div>
			<p>MongoDB的备份工具叫mongodump，该工具作为标准发行版本的一部分。</p>
			<p><strong>注意：</strong>1、MongoDB服务器运行在你目前登录的机器上。</p>
			<p>硬盘空间中以容纳转储文件，该文件最大可能戌数据库大小相同。</p>
			<p>备份文件将保存在个人主目录中，这就避免了处理权限相关的问题。</p>
			<textarea>
				创建备份
				$> cd ~
				$> mkdir testmongobackup
				$> cd testmongobackup
				$> mongodump  (或者 /usr/local/mongo/bin/mongodump)

				从备份中恢复
				$> cd ~/testmongobackup
				$> mongorestore --drop    (此选项即在恢复集合之前先丢弃现有的数据.最终，备份数据将替换数据库现有的数据。
				如果不使用--drop选项，被恢复的数据将被追加到每个集合的尾部，这将导致出现重复的数据)
			</textarea>
		</div>

		<h3>备份单个数据库</h3>
		<div>
			<p>mongodump 提供了 -d database_name选项用于实现单个数据库的备份。mongodump工具将为它创建./dump文件夹,该文件夹中将只包含单个数据库的所有备份文件。</p>
		</div>

		<h3>备份单个集合</h3>
		<div>
			<p>mongodump 提供了 -c 选项用于实现单个集合的备份。注意：mongodump工具不会清空目标目录。这意味着，对于每个希望备份的集合，都可以成功调用mongodump将指定的集合添加到备份中。</p>
			<textarea>
				$mkdir ~/backuptemp
				$cd ~/backuptemp
				$mongodump -d blog -c posts     备份数据库blog里的posts集合
				$mongodump -d bloc -c tagcloud  备份数据库blog里的tagcloud集合
			</textarea>
		</div>

	</div>

	<h2>数据安全(备份 恢复 升级 监控)</h2>
	<div>

		<h3>认证</h3>
		<div>
			<p>MongoDB支持简单的基于角色的认证系统，通过该系统可以控制用户对数据库的访问以及他们被授予的访问级别。</p>
			<p>默认情况下，MongoDB不使用任何认证方式。任何可以访问网络的人都可以连接到服务器并执行命令。</p>
			<p>可以在任何数据库添加用户，这样就可以对MongoDB进行配置 ，使得在访问数据库时既要求有连接，还需要进行控制台验证，这是限制对管理函数访问的推荐方式。</p>
			<p>添加admin用户</p>
			<textarea>
				$> mongo
				> use admin
				> db.addUser({user:"admin",pwd:"pass",roles:["readWrite","dbAdmin"]});
				> db.createUser({user:"mongo",pwd:"123456",roles:[{"role":"userAdminAnyDatabase","db":"admin"}]}); 版本3.2中使用这个命令增加用户
			</textarea>
		</div>

		<h3>用户角色功能描述</h3>
		<div>
			<table>
				<tbody>
					<tr><th>角色表示</th><th>角色功能</th></tr>
					<tr><td>Read</td><td>允许用户读取指定的数据库</td></tr>
					<tr><td>dbAdmin</td><td>允许用户在指定的数据库中执行管理函数，例如创建或删除索引、查看统计或访问system.profile集合</td></tr>
					<tr><td>userAdmin</td><td>允许用户向system.users集合中写入。具有该权限的用户可以在该数据库中创建、删除和管理用户。</td></tr>
					<tr><td>clusterAdmin</td><td>史在admim数据库中可用。为用户赋予所有分片和复制集相关函数的完全管理权限。</td></tr>
					<tr><td>readAnyDatabase</td><td>只在admin数据库中可用。为用户赋予所有数据读写权限</td></tr>
					<tr><td>userAdminAnyDatabase</td><td>只在admin数据库中可用。为用户赋予所有数据库的userAdmin权限</td></tr>
					<tr><td>dbAdminAnyDatabase</td><td>只在admin数据库中可用。为用户赋予所有数据dbAdmin读写权限</td></tr>
				</tbody>
			</table>
		</div>

	</div>

	<h2>优化</h2>
	<div>
		<h3>优化服务器硬件</h3>
		<div>
			<p>通常对数据库进行的最快速也是最便宜的优化就是为之选择正确大小的硬件。如果数据库服务器的内存太少或者驱动器速度太低，就可能会对数据库性能产生巨大影响。</p>
			<p>MongoDB使用内存映射文件I/O来访问数据存储。第一个需要注意的是，在现代64位操作系统中，Linux中的最大文件可以达到128TB左右。Windows对内存映射文件的限制使得最大文件最多可以达到8TB（启用日志之后则保只有4TB）.在32位操作系统中，最大文件被限制为2GB，所以不推荐使用32位操作系统运行。</p>
			<p>第二个需要注意的地方是，内存映射文件将使用操作系统的虚拟内存，系统将需把数据文件的某个部分映射到RAM中。这会产生一个假象：MonogDB将会用尽系统的所有RAM。其实并不是这样，因为MongoDB将与其他应用一起共享虚拟地址空间。并且OS也会按需将内存释放给其他进程。</p>
		</div>

		<h3>评估查询性能</h3>
		<div>
			<p>explain是研究单个查询的好工具，通过它可以判断查询的执行性能。mongoDB分析器是查找性能不佳的查询以及选择查询用于进一检查的好工具。</p>
			<p>启用分析器，它将会影响服务器的性能，不要尝试为了提供最近执行的查询而保持分析器一直运行。</p>
			<p>启用分析器：<strong>use blog;　db.setProfilingLevel(1);</strong></p>
			<p>禁用分析器：<strong>use blog;　db.setProfilingLevel(0);</strong></p>
			<p>针对超过了特定执行时间的查询启用分析器，比如记录执行超过半秒钏的查询：<strong>use blog; db.setProfilingLevel(1,500);</strong></p>
			<p>将分析级别设置为2,可以为所有的查询启用分析器：<strong>use blog; db.setProfilingLevel(2);</strong></p>
			<p>最常用的，也是MongoDB所使用的唯一索引类型是btree(二叉树)。BtreeCursor是MongoDB的一种数据游标，使用二叉树索引遍历文档。btree索引在数据库系统中非常常见，因为它们提供了更快的插入和删除速度，而在遍历数据或对数据排序时，也提供了合理的性能。</p>
		</div>
	</div>

	<h2>复制</h2>
	<div>
		<h3>复制的定义</h3>
		<div>
			<p>在所有特性中，复制被用于实现可扩展性，可持久性/可靠性和隔离性。</p>
			<p>复制可以通过两种方式帮助创建更具扩展性的应用：提高冗余度，改善性能。</p>
			<p>复制集(或replSet)是一种创建多个MongoDB实例的方式，这些实例将拥有相同的数据(冗余)和其他相关设置。</p>
			<p>复制方式包括：主/从复制　主/主复制　复制对。 在MongoDB中，一个复制集由一个主节点和许多辅助或仲裁节点组成。</p>
			<p>复制集成员的个数应该为奇数，这意味着最小应该有3个节点。之所以有该要求是因为，MongoDB中有一条规则：主服务必须能够看到其他的大多数节点，才能继续成为主服务器。这条规则主要是为了避免“脑裂”(Split Brain)问题，也就是当网络出现问题时，有两台服务器成为主服务器情况。</p>
		</div>

		<h3>主服务器的定义</h3>
		<div>
			<p>在复制集的术语中，主服务器是在特定的时间内复制集的数据来源。它是复制集中唯一可以写入的节点，所有其他的节点都将从这里复制抽它们的数据。主服务器由所有投票成员中的大多数选择产生，这被称为法定人数(quorum)。</p>
			<p>一旦选择主服务器，所有辅助服务器将使用它作为复制数据的来源，并且所有的写入都必须被重向至该成员。</p>
		</div>

		<h3>创建复制集的步骤</h3>
		<div>
			<p>1、创建复制集</p>
			<p>2、启动服务器成员</p>
			<p>3、向复制集中添加服务器</p>
			<p>4、添加仲裁服务器</p>
			<p>5、</p>
		</div>

	</div>



</body>
</html>
