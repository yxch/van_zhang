



语法：(“/\<img\>*src=\”.*?\”\/\>/iu”)
①定界符 
// 除字母，数字和正斜线\以外的任何字符都可以当作定界符。没有特殊需要，我们都使用反斜线来表示定界符，有些语言不需要定界符。
②原子
img \s. 原子是正则表达式最基本的组成单位，只要是正则表达式就必须至少包含一个原子。一个正则表达式可以单独使用的字符，就是原子。
由所有打印（所有可以在屏幕上输出的字符）和非打印字符（回车，空格等），
. * + ? （< >这些字符必须使用\转义字符转义。转义字符可以将有意义的字符转成无意义的字符，也可以将无意义的字符转义成有意义的字符。
在正则表达中可以直接使用一些代表范围的原子：
\d   表示一个任意的十进制数字 [0-9]
\D 表示任意一个除了十进制的数字以外的所有字符 [^0-9]
\s 匹配任意一个空白字符，空格，回车，\n \r \t \f [\n\r\t\f]
\S 匹配任意一个非空白字符。 [^\n\r\t\f]
\w 表示任意一个字 a-z A-Z 0-9 _   [a-zA-Z0-9_]
\W 表示任意一个非字的字符。 [^a-zA-Z0-9_]
如果要自己定义一个原子表就使用[ ]来表示，可以匹配方括号中的任何一个原子比如：[13579][a-z5-8],而这个^就是取反[^abc]表示除了abc都可以,但^符号必须在第一个位置。
③元字符 
* ? + . | { } ( ) 元字符是一种特殊的字符，是用来修饰原子用的，不可以单独出现。
* 表示其前面的原子可以出现0次 ，1次，或多次
+ 表示其前面的原子可以出现1次，或多次，但不能一次都没有
? 表示其前面的原子可以出现1次，或0次
{ } 表示自己定义前面原子出现的次数 {m} 表示前面的原子出现m次; {m,n}表示前面的原子最少m次，最多n次，包括mn次。｛m,｝表示前面的原子最少出现m次，没有最多限定。
. 默认情况下表示除换行符外，任意一个字符；
^如果不放在原子表里，而直接出现在正则表达式的第一个字符，表示以这个正则开始 “/^one/”表示必须以字符串one开始。
$ 直接在一个正则表达式最后一个字符，表示必须以前面原子结尾的字符串。
| 表示或者的关系 “/a|b/”表示在字符串要么出a要么出现b。它的优先级别最低。
\b 表示一个边界
\B 表示一个非边界
( ) 重点 它的功能非常多： ①作为大原子使用。 “/(abc)+/”   ②改变优先级,可以提高优先级  ③作为子模式使用 ④可以取消子模式，可以将其作为大原子来改变优先级使用，在括号前面使用”?:”来取消它的子模式 ⑤反向引用，可以在模式中直接将子模式取出来，再作为正则表达式模式的一部分，如果是在正则表达式像替换函数preg_replace函数中，可以将子模式取出，在被替换的字符串中使用。 \1,取第一个子模式 \2取第二个子模式… 依次类推。注意要看是单引号还是双引号的正则表达
④模式修正符（i u ）
模式修正符在定界符之后，就是几个字母，可以一次使用一个，每一个具一定的意义，也可以连续使用多个，是对整个正则表达式调优，或者对正则表达式功能的扩展。
i：在和模式匹配时不区分大小写
m：默认将字符串视为一行， ^$视为多行，任何一行都可以以正则表达式开始或结束。
s：如果没有使用这个模式修正符，那元字符中的”.”默认就不能表示换行符号，将字符串视为单行。
x：表示模式中的空白忽略不计
e：正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用
A：强制以某个原子开头
Z：强制以某个原子结尾
U：正则表达式的特点，就是比较“贪婪”，只要符合要求，就全部匹配。如果使用模式修正符U可以解决这种贪婪匹配，有些语言中不支持这种模式修正符比如javascript。还可以使用?来取消贪婪匹配，这两方法不能同时使用。

=================================正则表达式示例======================================
//正则表达式匹配img标签
/<img[^>]*?>.*?<\/>/si
/<img(.*)src=\"([^\"]+)\"[^>]+>/isU

//中文判断
preg_match("/^[\u4e00-\u9fa5]+$/",$str)

//手机号码匹配正则表达式  推荐使用函数处理
var regx = /^(13[0-9]|147|145|15[0-9]|17[0-9]|18[0-9])\d{8}$/;  
return regx.test($('#mobile').val());

str.replace(/^\s*/g,"");  //去除str左侧空格
str.replace(/\s*$/g,"");  //去除str右侧空格
str.replace(/(^\s*)|(\s*$)/g, "");  //去除两端的空格
str.replace(/\s/g,'');  //去除中间的空格

var reg=/^[0-9]*$/; return reg.test(str); //匹配整数  推荐使用函数处理
var reg=/^(-|\+)?\d+$/;  return reg.test(str); //验证是否为整数，包括正负数；
var reg=/^\d+$/;  return reg.test(str); //是大于0的整数
var reg=/^-\d+$/; return reg.test(str); //负整数的验证
var check_float =new RegExp("^[1-9][0-9]*\.[0-9]+$"); return check_float.exec(str); //为浮点数（正数）
var reg=/^[0-9]{3,4}\-\d{7,8}(\(\d{1,6}\))?$/; return reg.test(str); //是否为固定电话，区号3到4位，号码7到8位,区号和号码用"－"分割开，转接号码为1到6位，用小括号括起来紧跟在号码后面
var reg=/^[\u0391-\uFFE5]+$/; return reg.test(str); //验证是否为中文
var reg=/^[1-9]\d{4,9}$/; return reg.test(str); //验证是否为qq号码，长度为5－10位
var reg=/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/; return reg.test(str); //验证邮件地址
